{
  "id": "rotting-oranges",
  "title": "Rotting Oranges",
  "difficulty": "Medium",
  "functionName": "orangesRotting",
  "runner": "rottingOranges",
  "prompt": "Given a 2D grid where:\n- 0 represents an empty cell,\n- 1 represents a fresh orange,\n- 2 represents a rotten orange,\nreturn the minimum number of minutes until all oranges are rotten.\n\nEach minute, any fresh orange adjacent (up, right, down, left) to a rotten orange becomes rotten.\nIf it is impossible to rot all oranges, return -1.\nIf there are no oranges, return 0.",
  "constraintQuestions": [
    "Are only up/down/left/right adjacencies valid? (Yes.)",
    "What if no fresh oranges exist? (Return 0.)",
    "What if fresh oranges can never be reached? (Return -1.)",
    "Can there be multiple starting rotten oranges? (Yes.)",
    "Should we mutate the grid? (Allowed.)"
  ],
  "starterCode": "// Write your solution in JavaScript.\n// Requirement: define a function named orangesRotting(grid)\n// Return: number of minutes\n\nfunction orangesRotting(grid) {\n  // TODO: implement\n  return 0;\n}\n",
  "walkthrough": [
    {
      "title": "Multi-source BFS",
      "body": "Scan the grid to collect all rotten oranges into a queue and count fresh oranges.\nPerform BFS level by level (each level is a minute).\nWhen a fresh orange is reached, rot it and decrement the fresh count.\nAt the end, if fresh > 0 return -1; otherwise return minutes."
    },
    {
      "title": "JavaScript (BFS implementation)",
      "codeLanguage": "javascript",
      "body": "function orangesRotting(grid) {\n  if (!grid.length || !grid[0].length) return 0;\n  const rows = grid.length;\n  const cols = grid[0].length;\n  const queue = [];\n  let fresh = 0;\n\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (grid[r][c] === 2) queue.push([r, c]);\n      else if (grid[r][c] === 1) fresh++;\n    }\n  }\n\n  const dirs = [\n    [-1, 0],\n    [0, 1],\n    [1, 0],\n    [0, -1],\n  ];\n\n  let minutes = 0;\n  let layer = queue.length;\n\n  while (queue.length) {\n    if (layer === 0) {\n      minutes++;\n      layer = queue.length;\n    }\n\n    const [r, c] = queue.shift();\n    layer--;\n\n    for (const [dr, dc] of dirs) {\n      const nr = r + dr;\n      const nc = c + dc;\n      if (nr < 0 || nr >= rows || nc < 0 || nc >= cols) continue;\n      if (grid[nr][nc] !== 1) continue;\n      grid[nr][nc] = 2;\n      fresh--;\n      queue.push([nr, nc]);\n    }\n  }\n\n  return fresh > 0 ? -1 : minutes;\n}\n"
    },
    {
      "title": "Complexity",
      "body": "Time: O(r*c) because each cell is processed at most once.\nSpace: O(r*c) for the queue in the worst case."
    }
  ],
  "tests": [
    {
      "name": "All rot in 7 minutes",
      "matrix": [
        [2, 1, 1, 0, 0],
        [1, 1, 1, 0, 2],
        [0, 1, 0, 1, 1],
        [0, 1, 1, 1, 0]
      ],
      "expect": 7
    },
    {
      "name": "Unreachable fresh orange",
      "matrix": [
        [2, 1, 1, 0, 2],
        [1, 1, 0, 0, 1],
        [0, 0, 0, 0, 1]
      ],
      "expect": -1
    },
    { "name": "Empty grid", "matrix": [], "expect": 0 },
    { "name": "No fresh oranges", "matrix": [[0, 2, 0]], "expect": 0 },
    { "name": "All fresh but no rotten", "matrix": [[1, 1], [1, 1]], "expect": -1 }
  ]
}
