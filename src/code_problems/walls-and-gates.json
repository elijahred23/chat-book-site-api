{
  "id": "walls-and-gates",
  "title": "Walls and Gates",
  "difficulty": "Medium",
  "functionName": "wallsAndGates",
  "runner": "wallsAndGates",
  "prompt": "You are given a 2D grid where:\n- -1 represents a wall,\n- 0 represents a gate,\n- 2147483647 represents an empty room.\n\nFill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, leave it as 2147483647.\nReturn the modified grid.",
  "constraintQuestions": [
    "Are moves only up, right, down, left? (Yes.)",
    "Should we return the same grid after modification? (Yes.)",
    "What should we do with unreachable rooms? (Leave as 2147483647.)",
    "Can there be multiple gates? (Yes.)",
    "Is an empty grid valid? (Yes, return as-is.)"
  ],
  "starterCode": "// Write your solution in JavaScript.\n// Requirement: define a function named wallsAndGates(rooms)\n// Return: modified matrix\n\nfunction wallsAndGates(rooms) {\n  // TODO: implement\n  return rooms;\n}\n",
  "walkthrough": [
    {
      "title": "Multi-source BFS from gates",
      "body": "Start BFS from all gates at once.\nEach BFS layer increases distance by 1.\nWhen you reach an empty room with INF, set its distance and enqueue it.\nWalls are skipped."
    },
    {
      "title": "JavaScript (BFS implementation)",
      "codeLanguage": "javascript",
      "body": "function wallsAndGates(rooms) {\n  if (!rooms.length || !rooms[0].length) return rooms;\n  const rows = rooms.length;\n  const cols = rooms[0].length;\n  const INF = 2147483647;\n  const queue = [];\n\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (rooms[r][c] === 0) queue.push([r, c]);\n    }\n  }\n\n  const dirs = [\n    [-1, 0],\n    [0, 1],\n    [1, 0],\n    [0, -1],\n  ];\n\n  while (queue.length) {\n    const [r, c] = queue.shift();\n    for (const [dr, dc] of dirs) {\n      const nr = r + dr;\n      const nc = c + dc;\n      if (nr < 0 || nr >= rows || nc < 0 || nc >= cols) continue;\n      if (rooms[nr][nc] !== INF) continue;\n      rooms[nr][nc] = rooms[r][c] + 1;\n      queue.push([nr, nc]);\n    }\n  }\n\n  return rooms;\n}\n"
    },
    {
      "title": "Complexity",
      "body": "Time: O(r*c) because each cell is processed at most once.\nSpace: O(r*c) for the queue in the worst case."
    }
  ],
  "tests": [
    {
      "name": "All rooms reachable",
      "matrix": [
        [2147483647, -1, 0, 2147483647],
        [2147483647, 2147483647, 2147483647, -1],
        [2147483647, -1, 2147483647, -1],
        [0, -1, 2147483647, 2147483647]
      ],
      "expect": [
        [3, -1, 0, 1],
        [2, 2, 1, -1],
        [1, -1, 2, -1],
        [0, -1, 3, 4]
      ]
    },
    {
      "name": "Unreachable room",
      "matrix": [
        [2147483647, -1, 0],
        [-1, 2147483647, -1],
        [0, -1, 2147483647]
      ],
      "expect": [
        [2147483647, -1, 0],
        [-1, 2147483647, -1],
        [0, -1, 2147483647]
      ]
    },
    { "name": "Empty grid", "matrix": [], "expect": [] }
  ]
}
