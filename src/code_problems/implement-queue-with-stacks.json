{
  "id": "implement-queue-with-stacks",
  "title": "Implement Queue With Stacks",
  "difficulty": "Medium",
  "functionName": "QueueWithStacks",
  "runner": "queueWithStacks",
  "prompt": "Implement a queue using stacks. Your class should support:\n- enqueue(x): add x to the back of the queue.\n- dequeue(): remove and return the value at the front of the queue.\n- peek(): return the front value without removing it.\n- empty(): return true if the queue is empty, else false.\n\nAssume all operations are valid (dequeue/peek won't be called on an empty queue).\nUse two stacks internally.",
  "constraintQuestions": [
    "Can we assume dequeue/peek are only called when the queue is non-empty? (Yes.)",
    "Are we allowed to use two stacks? (Yes, required.)",
    "Do we need amortized O(1) per operation?",
    "Should enqueue be O(1) and dequeue/peek amortized O(1)?",
    "Do we need to implement as a class?"
  ],
  "starterCode": "// Write your solution in JavaScript.\n// Requirement: define a class named QueueWithStacks\n// Methods: enqueue(x), dequeue(), peek(), empty()\n\nclass QueueWithStacks {\n  constructor() {\n    // TODO: initialize stacks\n  }\n\n  enqueue(x) {\n    // TODO: implement\n  }\n\n  dequeue() {\n    // TODO: implement\n  }\n\n  peek() {\n    // TODO: implement\n  }\n\n  empty() {\n    // TODO: implement\n  }\n}\n",
  "walkthrough": [
    {
      "title": "Two-stack insight",
      "body": "Use two stacks: inStack for enqueue operations and outStack for dequeue/peek.\n- enqueue(x): push into inStack.\n- dequeue/peek: if outStack is empty, move all items from inStack to outStack (reverses order).\nThen pop/peek from outStack.\n- empty(): both stacks must be empty."
    },
    {
      "title": "JavaScript (class implementation)",
      "codeLanguage": "javascript",
      "body": "class QueueWithStacks {\n  constructor() {\n    this.inStack = [];\n    this.outStack = [];\n  }\n\n  enqueue(x) {\n    this.inStack.push(x);\n  }\n\n  _shift() {\n    if (this.outStack.length) return;\n    while (this.inStack.length) {\n      this.outStack.push(this.inStack.pop());\n    }\n  }\n\n  dequeue() {\n    this._shift();\n    return this.outStack.pop();\n  }\n\n  peek() {\n    this._shift();\n    return this.outStack[this.outStack.length - 1];\n  }\n\n  empty() {\n    return this.inStack.length === 0 && this.outStack.length === 0;\n  }\n}\n"
    },
    {
      "title": "Complexity",
      "body": "enqueue: O(1).\ndequeue/peek: amortized O(1) due to occasional shifts.\nSpace: O(n)."
    }
  ],
  "tests": [
    {
      "name": "Basic operations",
      "ops": ["QueueWithStacks", "enqueue", "enqueue", "peek", "dequeue", "empty"],
      "args": [[], [1], [2], [], [], []],
      "expect": [null, null, null, 1, 1, false]
    },
    {
      "name": "Interleaved enqueue/dequeue",
      "ops": ["QueueWithStacks", "enqueue", "enqueue", "dequeue", "enqueue", "peek", "dequeue", "dequeue", "empty"],
      "args": [[], [10], [20], [], [30], [], [], [], []],
      "expect": [null, null, null, 10, null, 20, 20, 30, true]
    },
    {
      "name": "Peek without removal",
      "ops": ["QueueWithStacks", "enqueue", "enqueue", "peek", "peek", "dequeue", "peek"],
      "args": [[], [5], [7], [], [], [], []],
      "expect": [null, null, null, 5, 5, 5, 7]
    }
  ]
}
